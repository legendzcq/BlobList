#é”ğŸ”
> Linuxä½œä¸ºå¤šä»»åŠ¡ç³»ç»Ÿï¼Œèƒ½å¤ŸåŒæ—¶è¿è¡Œå‡ ä¸ªè¿›ç¨‹ã€‚é€šå¸¸ï¼Œå„ä¸ªè¿›ç¨‹å¿…é¡»å°½å¯èƒ½ç‹¬ç«‹ï¼Œé¿å…å½¼æ­¤æ‰“æ‰°ï¼Œè¿™å¯¹äºä¿æŠ¤æ•°æ®å’Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§å¾ˆæœ‰å¿…è¦ï¼Œä½†æœ‰æ—¶å€™ï¼Œåº”ç”¨ç¨‹åºå¿…é¡»å½¼æ­¤é€šä¿¡ã€‚
>

 ä¸¾ä¾‹æ¥è¯´ï¼š
**ä¸€ä¸ªè¿›ç¨‹ç”Ÿæˆçš„æ•°æ®ä¼ è¾“åˆ°å¦ä¸€ä¸ªè¿›ç¨‹æ—¶ï¼š**
**æ•°æ®ç”±å¤šä¸ªè¿›ç¨‹å…±äº«æ—¶ï¼š**
**è¿›ç¨‹å¿…é¡»å½¼æ­¤ç­‰å¾…æ—¶ï¼š**
**éœ€è¦åè°ƒèµ„æºçš„ä½¿ç”¨æ—¶ï¼š**

![0_1274184015NC2q](./image/0_1274184015NC2q.gif)

##æ§åˆ¶æœºåˆ¶
### ç«äº‰æ¡ä»¶
å½“å¤šä¸ªè¿›ç¨‹éƒ½ä¼å›¾å¯¹å…±äº«æ•°æ®è¿›è¡ŒæŸç§å¤„ç†ï¼Œè€Œæœ€åçš„ç»“æœåˆå–å†³äºè¿›ç¨‹è¿›è¡Œçš„é¡ºåºæ—¶ï¼Œåˆ™æˆ‘ä»¬è®¤ä¸ºè¿™å‘ç”Ÿäº†ç«äº‰æ¡ä»¶ã€‚ä¸€ä¸ªä¾‹å­æ˜¯åœ¨forkå‡ºå­è¿›ç¨‹ä¹‹åï¼Œçˆ¶ã€å­è¿›ç¨‹çš„æ‰§è¡Œé¡ºåºæ˜¯ä¸ç¡®å®šçš„ï¼Œè¿™ç§ä¸ç¡®å®šå†³å®šäº†åé¢ç¨‹åºçš„ç»“æœï¼Œé‚£ä¹ˆè¿™ä¾¿äº§ç”Ÿäº†ä¸€ä¸ªç«äº‰æ¡ä»¶ã€‚
``` c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
 
static void charatatime(char *str)
{
    char *ptr;
    int c;
 
    setbuf(stdout, NULL);  /* æ ‡å‡†è¾“å‡ºè®¾ç½®ä¸ºä¸å¸¦ç¼“å†² */
    for (ptr = str; (c = *ptr++) != 0; )
        putc(c, stdout);
}
 
int main(void)
{
    pid_t pid;
 
    pid = fork();
    if (pid == 0)
        charatatime("output from child\n");
    else
        charatatime("output from parent\n");
 
    return 0;
}
ä¸Šè¿°ç¨‹åºç”±forkäº§ç”Ÿäº†ä¸€ä¸ªç«äº‰æ¡ä»¶ã€‚æŠŠæ ‡å‡†è¾“å‡ºçš„ç¼“å†²åŒºå¤§å°è®¾ä¸ºäº†0ï¼Œæ¯è¾“å…¥ä¸€ä¸ªå­—ç¬¦å°±è°ƒç”¨ä¸€æ¬¡writeç³»ç»Ÿè°ƒç”¨ï¼Œå¢å¤§äº†è¿›ç¨‹è¿è¡Œæ—¶é—´ï¼Œä¸ºçš„æ˜¯è®©ä¸¤ä¸ªè¿›ç¨‹å°½å¯èƒ½çš„åˆ‡æ¢ã€‚
```
è¿è¡Œç»“æœï¼š
```
output from parent
output from child
Program ended with exit code: 0
```

### ä¸´ç•ŒåŒº
ä¿è¯åœ¨æŸä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½è®¿é—®æ•°æ®çš„ç®€ä¾¿åŠæ³•ã€‚åœ¨ä»»æ„æ—¶åˆ»åªå…è®¸ä¸€ä¸ªçº¿ç¨‹å¯¹å…±äº«èµ„æºè¿›è¡Œè®¿é—®ã€‚å¦‚æœæœ‰å¤šä¸ªçº¿ç¨‹è¯•å›¾åŒæ—¶è®¿é—®ä¸´ç•ŒåŒºï¼Œé‚£ä¹ˆåœ¨æœ‰ä¸€ä¸ªçº¿ ç¨‹è¿›å…¥åå…¶ä»–æ‰€æœ‰è¯•å›¾è®¿é—®æ­¤ä¸´ç•ŒåŒºçš„çº¿ç¨‹å°†è¢«æŒ‚èµ·ï¼Œå¹¶ä¸€ç›´æŒç»­åˆ°è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ç¦»å¼€ã€‚ä¸´ç•ŒåŒºåœ¨è¢«é‡Šæ”¾åï¼Œå…¶ä»–çº¿ç¨‹å¯ä»¥ç»§ç»­æŠ¢å ï¼Œå¹¶ä»¥æ­¤è¾¾åˆ°ç”¨åŸå­æ–¹å¼æ“ ä½œå…±äº«èµ„æºçš„ç›®çš„ã€‚ 

### ä¿¡å·é‡
å®è´¨ä¸Šï¼Œä¿¡å·é‡åªæ˜¯å—ä¿æŠ¤çš„ç‰¹åˆ«å˜é‡ï¼Œèƒ½å¤Ÿè¡¨ç¤ºä¸ºæ­£è´Ÿæ•´æ•°ï¼Œå…¶åˆå§‹åŒ–å€¼ä¸º1.
ä¸ºæ“ä½œä¿¡å·é‡å®šä¹‰äº†ä¸¤ä¸ªæ ‡å‡†æ“ä½œï¼šup å’Œ downï¼Œè¿™ä¸¤ä¸ªæ“ä½œåˆ†åˆ«ç”¨äºæ§åˆ¶å…³é”®ä»£ç èŒƒå›´çš„è¿›å…¥å’Œé€€å‡ºï¼Œä¸”å‡è®¾ç›¸äº’ç«äº‰çš„è¿›ç¨‹æ–¹ä½ä¿¡å·é‡æœºä¼šå‡ç­‰ã€‚
ä¿¡å·é‡åœ¨ç”¨æˆ·å±‚å¯ä»¥æ­£å¸¸å·¥ä½œï¼ŒåŸåˆ™ä¸Šå¯ä»¥è§£å†³å†…æ ¸å„ç§é”é—®é¢˜ï¼Œä½†äº‹å®ä¸Šä¸æ˜¯è¿™æ ·ï¼Œä¿¡å·é‡çœ‹èµ·æ¥å®¹æ˜“å®ç°ï¼Œä½†éª‘å¼€é”€å¯¹å†…æ ¸æ¥è¯´è¿‡å¤§ï¼Œæ‰€ä»¥å†…æ ¸æä¾›äº†è®¸å¤šä¸åŒçš„é”å’ŒåŒæ­¥æœºåˆ¶çš„åŸå› ã€‚

## å†…æ ¸é”æœºåˆ¶
å†…æ ¸å¯ä»¥ä¸å—é™åˆ¶çš„æ–¹ä½æ•´ä¸ªåœ°å€ç©ºé—´ï¼Œåœ¨å¤šå¤„ç†å™¨ä¸Šä¼šæœ‰ä¸€äº›é—®é¢˜ï¼ˆå¦‚æœå‡ ä¸ªå¤„ç†å™¨åŒå¤„äºæ ¸å¿ƒæ€ï¼Œç†è®ºä¸Šå¯ä»¥åŒæ—¶æ–¹ä½åŒä¸€ä¸ªæ•°æ®ç»“æ„ï¼‰ï¼Œæœ€æ—©çš„è§£å†³åŠæ³•æ˜¯åªå…è®¸ä¸€ä¸ªå¤„ç†å™¨å¤„äºæ ¸å¿ƒæ€ï¼Œè¯¥æ–¹æ³•å› ä¸ºæ•ˆç‡ä¸é«˜ï¼Œå¾ˆå¿«è¢«åºŸå¼ƒäº†ã€‚
ç°åœ¨å†…æ ¸ä½¿ç”¨äº†ç”±é”ç»„æˆçš„ç»†é¢—ç²’åº¦ç½‘ç»œï¼Œæ¥æ˜ç¡®åœ°ä¿æŠ¤å„ä¸ªæ•°æ®ç»“æ„ã€‚å¦‚æœå¤„ç†å™¨Aåœ¨æ“ä½œæ•°æ®ç»“æ„Xï¼Œåˆ™å¤„ç†å™¨Bå¯ä»¥æ‰§è¡Œä»»ä½•å…¶ä»–çš„å†…æ ¸æ“ä½œï¼Œä½†ä¸èƒ½æ“ä½œXã€‚



**è¯»è€…/å†™æŠ˜é”ï¼š**è¿™äº›é”ä¼šåŒºåˆ†å¯¹æ•°æ®ç»“æ„çš„ä¸¤å‘¨ä¸åŒç±»å‹çš„è®¿é—®ã€‚ä»»æ„ä¹¦åçš„å¤„ç†å™¨éƒ½å¯ä»¥å¯¹æ•°æ®ç»“æ„è¿›è¡Œå¹¶å‘è®¿é—®ï¼Œä½†åªæœ‰ä¸€ä¸ªå¤„ç†å™¨èƒ½å¤Ÿè¿›è¡Œå†™è®¿é—®ï¼Œäº‹å®ä¸Šï¼Œåœ¨è¿›è¡Œå†™è®¿é—®æ—¶ï¼Œè¯»è®¿é—®æ—¶æ— æ³•è¿›è¡Œçš„ã€‚

### åŸå­æ“ä½œ

å®šä¹‰ï¼šè¿™æ˜¯æœ€ç®€å•çš„é”æ“ä½œã€‚ä¿è¯ç®€å•çš„æ“ä½œï¼Œä¾‹å¦‚è®¡æ—¶å™¨+1ã€‚

#### å¯¹æ•´æ•°çš„åŸå­æ“ä½œ 

å†…æ ¸å®šä¹‰äº†atomic_t ç±»å‹ç”¨ä½œè®¡æ•°å™¨çš„åŸå­æ“ä½œåŸºç¡€ã€‚æä¾›ä¸€ä¸ªç®€å•çš„è®¡æ•°å™¨åŠ 1çš„ä¾‹å­ï¼š

1.å°†è®¡æ•°å™¨å€¼ä»å†…å­˜å¤åˆ¶åˆ°å¤„ç†å™¨å¯„å­˜å™¨ï¼›

2.å°†å…¶å€¼åŠ 1ï¼›

3.å°†å¯„å­˜å™¨æ•°æ®å›å†™åˆ°å†…å­˜ï¼›

åŸå­çš„æ•°æ®ç»“æ„ï¼š

```c
/*
 * This type is the placeholder for a hardware interrupt number. It has to be
 * big enough to enclose whatever representation is used by a given platform.
 */
typedef unsigned long irq_hw_number_t;

typedef struct {
	int counter;
} atomic_t;

#ifdef CONFIG_64BIT
typedef struct {
	s64 counter;
} atomic64_t;
#endif
```

æ–‡ä»¶ç›®å½•ï¼š/linux-5.6.7/include/linux/types.h

åŸå­å˜é‡åªèƒ½å€ŸåŠ©`ATMIC_INIT` å®åˆå§‹åŒ–ï¼Œç”±äºåŸå­æ•°æ®ç±»å‹æœ€ç»ˆæ˜¯ç”¨æ™®é€šçš„Cè¯­è¨€ç±»å‹å®ç°çš„ï¼Œå†…æ ¸å°†æ ‡å‡†ç±»å‹çš„å˜é‡å°è£…åœ¨ç»“æ„ä½“ä¸­ï¼Œæ‰€ä»¥ä¸èƒ½ä½¿ç”¨æ™®é€šè¿ç®—ç¬¦å¤„ç†ï¼Œå¦‚++

```c
typedef struct {volatile int counter;} atomic_t;
```

åŸå­æ“ä½œï¼š

```c
//è¯»åŸå­å˜é‡çš„å€¼
static __inline__ int atomic_read(const atomic_t *v)
{
	int t;

	__asm__ __volatile__("lwz%U1%X1 %0,%1" : "=r"(t) : "m"(v->counter));

	return t;
}

//å°†vè®¾ç½®ä¸ºi
static __inline__ void atomic_set(atomic_t *v, int i)
{
	__asm__ __volatile__("stw%U0%X0 %1,%0" : "=m"(v->counter) : "r"(i));
}


```

| æ¥å£å‡½æ•°                                                     | æè¿°                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| static inline void atomic_add(int i, atomic_t *v)            | ç»™ä¸€ä¸ªåŸå­å˜é‡vå¢åŠ i                                         |
| static inline int atomic_add_return(int i, atomic_t *v)      | åŒä¸Šï¼Œåªä¸è¿‡å°†å˜é‡vçš„æœ€æ–°å€¼è¿”å›                              |
| static inline void atomic_sub(int i, atomic_t *v)            | ç»™ä¸€ä¸ªåŸå­å˜é‡vå‡å»i                                         |
| static inline int atomic_sub_return(int i, atomic_t *v)      | åŒä¸Šï¼Œåªä¸è¿‡å°†å˜é‡vçš„æœ€æ–°å€¼è¿”å›                              |
| static inline int atomic_cmpxchg(atomic_t *ptr, int old, int new) | æ¯”è¾ƒoldå’ŒåŸå­å˜é‡pträ¸­çš„å€¼ï¼Œå¦‚æœç›¸ç­‰ï¼Œé‚£ä¹ˆå°±æŠŠnewå€¼èµ‹ç»™åŸå­å˜é‡ã€‚ è¿”å›æ—§çš„åŸå­å˜é‡pträ¸­çš„å€¼ |
| atomic_inc(v)                                                | åŸå­å˜é‡çš„å€¼åŠ ä¸€                                             |
| atomic_inc_return(v)                                         | åŒä¸Šï¼Œåªä¸è¿‡å°†å˜é‡vçš„æœ€æ–°å€¼è¿”å›                              |
| atomic_dec(v)                                                | åŸå­å˜é‡çš„å€¼å‡å»ä¸€                                           |
| atomic_dec_return(v)                                         | åŒä¸Šï¼Œåªä¸è¿‡å°†å˜é‡vçš„æœ€æ–°å€¼è¿”å›                              |
| atomic_sub_and_test(i, v)                                    | ç»™ä¸€ä¸ªåŸå­å˜é‡vå‡å»iï¼Œå¹¶åˆ¤æ–­å˜é‡vçš„æœ€æ–°å€¼æ˜¯å¦ç­‰äº0           |
| atomic_add_negative(i,v)                                     | ç»™ä¸€ä¸ªåŸå­å˜é‡vå¢åŠ iï¼Œå¹¶åˆ¤æ–­å˜é‡vçš„æœ€æ–°å€¼æ˜¯å¦æ˜¯è´Ÿæ•°          |
| static inline int atomic_add_unless(atomic_t *v, int a, int u) | åªè¦åŸå­å˜é‡vä¸ç­‰äºuï¼Œé‚£ä¹ˆå°±æ‰§è¡ŒåŸå­å˜é‡våŠ açš„æ“ä½œã€‚ å¦‚æœvä¸ç­‰äºuï¼Œè¿”å›é0å€¼ï¼Œå¦åˆ™è¿”å›0å€¼ |

 **Tips:** åŸå­å˜é‡å¾ˆé€‚åˆæ•´æ•°æ“ä½œï¼Œä½†ä¸é€‚åˆæ¯”ç‰¹ä½æ“ä½œã€‚

åœ¨iosä¸‹çš„åŸç†ï¼š

```objective-c
//è®¾ç½®æˆå‘˜å˜é‡çš„@propertyå±æ€§æ—¶ï¼Œé»˜è®¤ä¸ºatomicï¼Œæä¾›å¤šçº¿ç¨‹å®‰å…¨ã€‚
//åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼ŒåŸå­æ“ä½œæ˜¯å¿…è¦çš„ï¼Œå¦åˆ™æœ‰å¯èƒ½å¼•èµ·é”™è¯¯çš„ç»“æœã€‚åŠ äº†atomicï¼Œsetterå‡½æ•°ä¼šå˜æˆä¸‹é¢è¿™æ ·ï¼š
{lock}
    if (property != newValue) { 
        [property release]; 
         property = [newValue retain]; 
    }
{unlock}
```

å¦‚æœçº¿ç¨‹ A è°ƒäº† getterï¼Œä¸æ­¤åŒæ—¶çº¿ç¨‹ B ã€çº¿ç¨‹ C éƒ½è°ƒäº† setterâ€”â€”é‚£æœ€åçº¿ç¨‹ A get åˆ°çš„å€¼ï¼Œæœ‰3ç§å¯èƒ½ï¼šå¯èƒ½æ˜¯ Bã€C set ä¹‹å‰åŸå§‹çš„å€¼ï¼Œä¹Ÿå¯èƒ½æ˜¯ B set çš„å€¼ï¼Œä¹Ÿå¯èƒ½æ˜¯ C set çš„å€¼ã€‚åŒæ—¶ï¼Œæœ€ç»ˆè¿™ä¸ªå±æ€§çš„å€¼ï¼Œå¯èƒ½æ˜¯ B set çš„å€¼ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯ C set çš„å€¼ã€‚æ‰€ä»¥atomicå¯å¹¶ä¸èƒ½ä¿è¯å¯¹è±¡çš„çº¿ç¨‹å®‰å…¨ã€‚

``````objective-c
		@property(atomic,assign)int number;
		//@property(nonatomic,assign)int number;


    // 1.åˆ›å»ºé˜Ÿåˆ—
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    // 2.è®¾ç½®æœ€å¤§å¹¶å‘æ“ä½œæ•°
    queue.maxConcurrentOperationCount =3;
    // 3.æ·»åŠ æ“ä½œ
    [queue addOperationWithBlock:^{
        self.number = self.number + 1;
    }];
    [queue addOperationWithBlock:^{
        self.number = self.number + 100;
    }];
    [queue addOperationWithBlock:^{
        NSLog(@"value:%d",self.number);
    }];
``````

æ‰“å°ç»“æœï¼š

```objective-c
value:102
```



### è‡ªæ—‹é”

Linuxå†…æ ¸ä¸­æœ€å¸¸è§çš„é”æ˜¯**è‡ªæ—‹é”(spin lock)**.è‡ªæ—‹é”æœ€å¤šåªèƒ½è¢«ä¸€ä¸ªå¯æ‰§è¡Œçº¿ç¨‹æŒæœ‰ã€‚å¦‚æœä¸€ä¸ªæ‰§è¡Œçº¿ç¨‹è¯•å›¾è·å¾—ä¸€ä¸ªè¢«äº‰ç”¨çš„è‡ªæ—‹é”ï¼Œé‚£ä¹ˆè¯¥çº¿ç¨‹å°±ä¼šä¸€ç›´è¿›è¡Œå¿™å¾ªç¯ï¼Œç­‰å¾…é”é‡æ–°å¯ç”¨ã€‚*ä¸€ä¸ªè¢«äº‰ç”¨çš„è‡ªæ—‹é”æ˜¯çš„è¯·æ±‚ä»–çš„çº¿ç¨‹åœ¨ç­‰å¾…é”é‡æ–°å¯ç”¨æ—¶è‡ªæ—‹ï¼ˆç‰¹åˆ«æµªè´¹å¤„ç†æ—¶é—´ï¼‰*ã€‚è¿™æ˜¯è‡ªæ—‹é”çš„è¦ç‚¹ã€‚æ‰€ä»¥è‡ªæ—‹é”ä¸åº”è¯¥é•¿æ—¶é—´æŒæœ‰ã€‚

#### æ•°æ®ç»“æ„å’Œç”¨æ³•

è‡ªæ—‹é”é€šè¿‡`spinlock_t`æ•°æ®ç»“æ„å®ç°(/linux-5.6.7/include/linux/spinlock_types.h)ï¼Œ

```c
////linux-5.6.7/include/linux/spinlock_types.h
typedef struct spinlock {
	union {
		struct raw_spinlock rlock;

#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
		struct {
			u8 __padding[LOCK_PADSIZE];
			struct lockdep_map dep_map;
		};
#endif
	};
} spinlock_t;

typedef struct raw_spinlock {
	arch_spinlock_t raw_lock;
#ifdef CONFIG_DEBUG_SPINLOCK
	unsigned int magic, owner_cpu;
	void *owner;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map dep_map;
#endif
} raw_spinlock_t;

/////linux-5.6.7/arch/arm/include/asm/spinlock_types.h
typedef struct {
	union {
		u32 slock;
		struct __raw_tickets {
#ifdef __ARMEB__
			u16 next;
			u16 owner;
#else
			u16 owner;
			u16 next;
#endif
		} tickets;
	};
} arch_spinlock_t;

#define __ARCH_SPIN_LOCK_UNLOCKED	{ { 0 } }

typedef struct {
	u32 lock;
} arch_rwlock_t;
```



####âš ï¸è­¦å‘Šï¼šè‡ªæ—‹é”æ˜¯ä¸å¯é€’å½’çš„

Linuxå†…æ ¸å®ç°çš„è‡ªæ—‹é”æ˜¯ä¸å¯é€’å½’çš„ï¼Œè¿™ç‚¹ä¸åŒäºå…¶ä»–ç³»ç»Ÿå®ç°ï¼ˆioså†…æ— æ­¤æ¦‚å¿µï¼‰ã€‚å¦‚æœä½ è¯•å›¾å¾—åˆ°ä¸€ä¸ªä½ æ­£æŒæœ‰çš„é”ï¼Œä½ å¿…é¡»è‡ªæ—‹ï¼Œç­‰å¾…ä½ è‡ªå·±é‡Šæ”¾è¿™ä¸ªé”ã€‚ä½†æ˜¯ä½ å·²ç»å¤„äºè‡ªæ—‹å¿™ç­‰ä¸­ï¼Œæ‰€ä»¥æ°¸è¿œæ²¡æœ‰æœºä¼šé‡Šæ”¾é”ï¼Œäºæ˜¯ä½ è¢«è‡ªå·±é”æ­»äº†ï¼Œåƒä¸‡è¦å°å¿ƒæ·é”ã€‚

è‡ªæ—‹é”å½“å‰çš„æŒæœ‰è€…ä¹Ÿæ— æ³•å¤šæ¬¡è·å¾—åŒä¸€è‡ªæ—‹é”ï¼

#### âš ï¸è­¦å‘Šï¼šå•æ ¸CPUä¸é€‚åˆä½¿ç”¨è‡ªæ—‹é”

å•æ ¸CPUä¸é€‚äºä½¿ç”¨è‡ªæ—‹é”ï¼Œè¿™é‡Œçš„å•æ ¸CPUæŒ‡çš„æ˜¯å•æ ¸å•çº¿ç¨‹çš„CPUï¼Œå› ä¸ºï¼Œåœ¨åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹æ˜¯å¤„åœ¨è¿è¡ŒçŠ¶æ€ï¼Œå‡è®¾è¿è¡Œçº¿ç¨‹Aå‘ç°æ— æ³•è·å–é”ï¼Œåªèƒ½ç­‰å¾…è§£é”ï¼Œä½†å› ä¸ºAè‡ªèº«ä¸æŒ‚èµ·ï¼Œæ‰€ä»¥é‚£ä¸ªæŒæœ‰é”çš„çº¿ç¨‹Bæ²¡æœ‰åŠæ³•è¿›å…¥è¿è¡ŒçŠ¶æ€ï¼Œåªèƒ½ç­‰åˆ°æ“ä½œç³»ç»Ÿåˆ†ç»™Açš„æ—¶é—´ç‰‡ç”¨å®Œï¼Œæ‰èƒ½æœ‰æœºä¼šè¢«è°ƒåº¦ã€‚è¿™ç§æƒ…å†µä¸‹ä½¿ç”¨è‡ªæ—‹é”çš„ä»£ä»·å¾ˆé«˜ã€‚

####è¯»-å†™è‡ªæ—‹é”

Linuxä¸‹ä¸€ç§é”ï¼Œå¯ä»¥å…è®¸ä¸€ä¸ªæˆ–å¤šä¸ªè¯»ä»»åŠ¡å¹¶å‘çš„æŒæœ‰è¯»è€…é”ï¼Œç›¸åï¼Œç”¨äºå†™çš„é”æœ€å¤šåªèƒ½è¢«ä¸€ä¸ªå†™ä»»åŠ¡æŒæœ‰ï¼Œè€Œä¸”ä¸èƒ½å¹¶å‘çš„è¯»æ“ä½œã€‚

```c
rwlock_t lock;     //å®šä¹‰rwlock
rwlock_init(&lock);    //åˆå§‹åŒ–rwlock

//è¯»æ—¶è·å–é”
read_lock(&lock);
...ä¸´ç•ŒåŒº...
read_unlock(&lock);

 //å†™æ—¶è·å–é”
write_lock_irqsave(&lock, flags);
â€¦ä¸´ç•ŒåŒº...
write_unlock_irqrestore(&lock, flags);
```



### ä¿¡å·é‡

ä¿¡å·é‡åœ¨åˆ›å»ºæ—¶éœ€è¦è®¾ç½®ä¸€ä¸ªåˆå§‹å€¼ï¼Œè¡¨ç¤ºåŒæ—¶å¯ä»¥æœ‰å‡ ä¸ªä»»åŠ¡å¯ä»¥è®¿é—®è¯¥ä¿¡å·é‡ä¿æŠ¤çš„å…±äº«èµ„æºï¼Œåˆå§‹å€¼ä¸º1å°±å˜æˆäº’æ–¥é”ï¼ˆMutexï¼‰ï¼Œå³åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªä»»åŠ¡å¯ä»¥è®¿é—®ä¿¡å·é‡ä¿æŠ¤çš„å…±äº«èµ„æºã€‚

è¿™äº›æ˜¯ç”¨ç»å…¸æ–¹æ³•å®ç°çš„ï¼Œåœ¨ç­‰å¾…ä¿¡å·é‡é‡Šæ”¾æ—¶ï¼Œå†…æ ¸è¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç›´è‡³è¢«å”¤é†’ã€‚å”¤é†’åï¼Œå†…æ ¸æ‰é‡æ–°å°è¯•è·å–ä¿¡å·é‡ã€‚ï¼ˆå¤šä¸ªè¿›ç¨‹å¯ä»¥åŒæ—¶æŒæœ‰ä¸€ä¸ªä¿¡å·é‡ï¼‰

ç”±äºä¿¡å·é‡å¯ä»¥ç¡®ä¿æ¯æ¬¡è‡ªç”±ä¸€ä¸ªäººè¿›å…¥ä¸´ç•ŒåŒºï¼Œå¦‚æœä¸´ç•ŒåŒºè¢«å ç”¨ï¼Œä»»åŠ¡ä¼šæŠŠè‡ªå·±åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸Šå¹¶è¿›å…¥ä¼‘çœ ï¼Œæ‰€ä»¥ä¿¡å·é‡æä¾›äº†æ›´å¥½çš„å¤„ç†å™¨åˆ©ç”¨ç‡ï¼Œå› ä¸ºæ²¡æŠŠæ—¶é—´èŠ±è´¹åœ¨å¿™ç­‰ä¸Šï¼Œä½†æ˜¯ä¿¡å·é‡æ¯”è‡ªæ—‹é”æœ‰æ›´å¤§çš„å¼€é”€ã€‚

```c
//  /linux-5.6.7/include/linux/semaphore.h

#include <linux/list.h>
#include <linux/spinlock.h>

/* Please don't access any members of this structure directly */
struct semaphore {
	raw_spinlock_t		lock; //è‡ªæ—‹é”
	unsigned int		count; //ä¿¡å·é‡
	struct list_head	wait_list; //
};

```

#### 1.ä¿¡å·é‡çš„downæ“ä½œ

`void down(struct semaphore *sem);`
`int down_interruptible(struct semaphore *sem);`
`int down_trylock(struct semaphore *sem);`



```c
// /linux-5.6.7/kernel/locking/semaphore.c
int down_interruptible(struct semaphore *sem)
{
	unsigned long flags;
	int result = 0;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(sem->count > 0))
		sem->count--;
	else
		result = __down_interruptible(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);

	return result;
}


```

å¯¹äºéœ€è¦ä¼‘çœ çš„æƒ…å†µï¼Œåœ¨`__down_interruptible()`å‡½æ•°ä¸­ï¼Œä¼šæ„é€ ä¸€ä¸ª`struct semaphore_waiter`ç±»å‹çš„å˜é‡ `struct semaphore_waiter`å®šä¹‰å¦‚ä¸‹ï¼š

```c
// /linux-5.6.7/kernel/locking/semaphore.c


struct semaphore_waiter 
{         
        struct list_head list;         
        struct task_struct *task;         
        int up; 
};
```

```c
// /linux-5.6.7/kernel/locking/semaphore.c


static inline int __sched __down_common(struct semaphore *sem, long state,
								long timeout)
{
	struct semaphore_waiter waiter;

	list_add_tail(&waiter.list, &sem->wait_list);
	waiter.task = current;
	waiter.up = false;

	for (;;) {
		if (signal_pending_state(state, current))
			goto interrupted;
		if (unlikely(timeout <= 0))
			goto timed_out;
		__set_current_state(state);
		raw_spin_unlock_irq(&sem->lock);
		timeout = schedule_timeout(timeout);
		raw_spin_lock_irq(&sem->lock);
		if (waiter.up)
			return 0;
	}

 timed_out:
	list_del(&waiter.list);
	return -ETIME;

 interrupted:
	list_del(&waiter.list);
	return -EINTR;
}
```



å°†å½“å‰è¿›ç¨‹èµ‹ç»™taskï¼Œå¹¶åˆ©ç”¨å…¶listæˆå‘˜å°†è¯¥å˜é‡çš„èŠ‚ç‚¹åŠ å…¥åˆ°ä»¥`sem`ä¸­çš„`wait_list`ä¸ºå¤´éƒ¨çš„ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼Œå‡è®¾æœ‰å¤šä¸ªè¿›ç¨‹åœ¨`sem`ä¸Šè°ƒç”¨`down_interruptible`ï¼Œåˆ™`sem`çš„`wait_listä¸Š`å½¢æˆçš„é˜Ÿåˆ—å¦‚ä¸‹å›¾ï¼š

![2012072109424763](2012072109424763.png)



**2.ä¿¡å·é‡çš„Væ“ä½œ (ä¼—å¤šçš„downå‡½æ•°,ä½†æ˜¯ä»…éœ€è¦ä¸€ä¸ªupå‡½æ•°)**

```c
// /linux-5.6.7/kernel/locking/semaphore.c


void up(struct semaphore *sem)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&sem->lock, flags);
	if (likely(list_empty(&sem->wait_list)))
		sem->count++;
	else
		__up(sem);
	raw_spin_unlock_irqrestore(&sem->lock, flags);
}
```

å¦‚æœæ²¡æœ‰å…¶ä»–çº¿ç¨‹ç­‰å¾…åœ¨ç›®å‰å³å°†é‡Šæ”¾çš„ä¿¡å·é‡ä¸Šï¼Œé‚£ä¹ˆåªéœ€å°†`count++`å³å¯ã€‚å¦‚æœæœ‰å…¶ä»–çº¿ç¨‹æ­£å› ä¸ºç­‰å¾…è¯¥ä¿¡å·é‡è€Œç¡çœ ï¼Œé‚£ä¹ˆè°ƒç”¨`__up`.

```c
// /linux-5.6.7/kernel/locking/semaphore.c
static noinline void __sched __up(struct semaphore *sem)
{
	struct semaphore_waiter *waiter = list_first_entry(&sem->wait_list,
						struct semaphore_waiter, list);
	list_del(&waiter->list);
	waiter->up = true;
	wake_up_process(waiter->task);
}


```

demoï¼š

```swift
        let semaphoreSignal = DispatchSemaphore(value:1)
        
        for index in 1...5 {
            DispatchQueue.global().async {
                semaphoreSignal.wait()
                print(Thread.current)
                print("è¿™æ˜¯ç¬¬\(index)æ¬¡æ‰§è¡Œ.\n")
                semaphoreSignal.signal()
            }
            print("æµ‹è¯•æ‰“å°")
            
        }
///
æµ‹è¯•æ‰“å°
æµ‹è¯•æ‰“å°
<NSThread: 0x600000b4b100>{number = 4, name = (null)}
æµ‹è¯•æ‰“å°
è¿™æ˜¯ç¬¬1æ¬¡æ‰§è¡Œ.

æµ‹è¯•æ‰“å°
æµ‹è¯•æ‰“å°
<NSThread: 0x600000b07640>{number = 3, name = (null)}
è¿™æ˜¯ç¬¬2æ¬¡æ‰§è¡Œ.

<NSThread: 0x600000b58c40>{number = 6, name = (null)}
è¿™æ˜¯ç¬¬3æ¬¡æ‰§è¡Œ.

<NSThread: 0x600000b4b100>{number = 4, name = (null)}
è¿™æ˜¯ç¬¬4æ¬¡æ‰§è¡Œ.

<NSThread: 0x600000b7c780>{number = 7, name = (null)}
è¿™æ˜¯ç¬¬5æ¬¡æ‰§è¡Œ.
```

```swift
        let semaphoreSignal = DispatchSemaphore(value:3)
        
        for index in 1...5 {
            DispatchQueue.global().async {
                semaphoreSignal.wait()
                print(Thread.current)
                print("è¿™æ˜¯ç¬¬\(index)æ¬¡æ‰§è¡Œ.\n")
                semaphoreSignal.signal()
            }
            print("æµ‹è¯•æ‰“å°")
            
        }
        //////
æµ‹è¯•æ‰“å°
<NSThread: 0x600001725580>{number = 4, name = (null)}
æµ‹è¯•æ‰“å°
è¿™æ˜¯ç¬¬1æ¬¡æ‰§è¡Œ.

æµ‹è¯•æ‰“å°
<NSThread: 0x600001750f80>{number = 5, name = (null)}
æµ‹è¯•æ‰“å°
<NSThread: 0x600001757ec0>{number = 6, name = (null)}
è¿™æ˜¯ç¬¬3æ¬¡æ‰§è¡Œ.

<NSThread: 0x600001725580>{number = 4, name = (null)}
æµ‹è¯•æ‰“å°
è¿™æ˜¯ç¬¬2æ¬¡æ‰§è¡Œ.

<NSThread: 0x600001760ac0>{number = 7, name = (null)}
è¿™æ˜¯ç¬¬5æ¬¡æ‰§è¡Œ.

è¿™æ˜¯ç¬¬4æ¬¡æ‰§è¡Œ.
```



**ä¸€äº›æœ‰æ„æ€çš„ç»“è®ºï¼š**

1.ç”±äºäº‰ç”¨ä¿¡å·é‡çš„è¿›ç¨‹åœ¨ç­‰å¾…é”é‡æ–°å˜ä¸ºå¯ç”¨æ—¶ä¼šç¡çœ ï¼Œæ‰€ä»¥ä¿¡å·é‡é€‚ç”¨äºé”ä¼šè¢«é•¿æ—¶é—´æŒæœ‰çš„æƒ…å†µã€‚

2.ç›¸åçš„ï¼Œé”è¢«çŸ­æ—¶é—´æŒæœ‰æ—¶ï¼Œä½¿ç”¨ä¿¡å·é‡å°±ä¸å¤ªé€‚å®œã€‚å› ä¸ºç¡çœ ï¼Œç»´æŠ¤ç­‰å¾…é˜Ÿåˆ—ä»¥åŠå”¤é†’æ‰€èŠ±è´¹çš„å¼€é”€å¯èƒ½æ¯”é”è¢«å ç”¨çš„å…¨éƒ¨æ—¶é—´è¿˜è¦é•¿ã€‚

3.å¯ä»¥å†æŒæœ‰ä¿¡å·é‡æ—¶å»ç¡çœ ï¼Œå› ä¸ºå…¶ä»–è¿›ç¨‹è¯•å›¾è·å¾—åŒä¸€ä¿¡å·é‡æ—¶ä¸ä¼šå› æ­¤è€Œæ­»é”ã€‚

4.åœ¨ä½ å ç”¨ä¿¡å·é‡çš„åŒæ—¶ä¸èƒ½å ç”¨è‡ªæ—‹é”ã€‚å› ä¸ºåœ¨ä½ ç­‰å¾…ä¿¡å·é‡æ—¶å¯èƒ½ä¼šç¡çœ ï¼Œè€Œåœ¨æŒæœ‰è‡ªæ—‹é”æ—¶ä¸å…è®¸ç¡çœ çš„ã€‚

####ä¿¡å·é‡ä¸è‡ªæ—‹é”çš„å¯¹æ¯”ï¼š

ä¿¡å·é‡ä¸åŒäºè‡ªæ—‹é”ï¼Œå®ƒä¸ä¼šç¦æ­¢å†…æ ¸æŠ¢å ï¼Œæ‰€ä»¥æŒæœ‰ä¿¡å·é‡çš„ä»£ç å¯ä»¥è¢«æŠ¢å ã€‚è¿™æ„å‘³è¿™ä¿¡å·é‡ä¸ä¼šå¯¹è°ƒåº¦çš„ç­‰å¾…æ—¶é—´å¸¦æ¥è´Ÿé¢å½±å“ã€‚

| éœ€æ±‚             | å»ºè®®çš„æ·é”æ–¹å¼ |
| ---------------- | -------------- |
| ä½å¼€é”€åŠ é”       | ä¼˜å…ˆä½¿ç”¨è‡ªæ—‹é” |
| çŸ­æœŸé”å®š         | ä¼˜å…ˆä½¿ç”¨è‡ªæ—‹é” |
| é•¿æœŸåŠ é”         | ä¼˜å…ˆä½¿ç”¨ä¿¡å·é‡ |
| ä¸­æ–­ä¸Šä¸‹æ–‡ä¸­åŠ é” | ä½¿ç”¨è‡ªæ—‹é”     |
| æŒæœ‰é”éœ€è¦ç¡çœ    | ä½¿ç”¨ä¿¡å·é‡     |

### é€’å½’é”

NSRecursiveLock defines a lock that may be acquired multiple times by the same thread without causing a deadlock, a situation where a thread is permanently blocked waiting for itself to relinquish a lock. While the locking thread has one or more locks, all other threads are prevented from accessing the code protected by the lock.
NSRecursiveLockå®šä¹‰äº†ä¸€ç§é”ï¼Œè¿™ç§é”èƒ½å¤Ÿåœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸Šå¤šæ¬¡åŠ é”ï¼Œè€Œä¸ä¼šå¼•èµ·æ­»é”ï¼ˆä¸€ä¸ªçº¿ç¨‹æ°¸è¿œçš„ç­‰å¾…è‡ªå·±è§£é”ï¼‰ã€‚å½“è¢«é”ä½çš„çº¿ç¨‹æœ‰ä¸€ä¸ªæˆ–è€…å¤šä¸ªé”çš„æ—¶å€™ï¼Œå…¶ä»–çº¿ç¨‹å°±ä¸èƒ½è®¿é—®è¢«ä¿æŠ¤çš„ä»£ç ã€‚

```swift
       func testRecursiveLock(){
               printPattern(n: 10)
           }
           func printPattern(n : Int) {
//               nsLock.lock()//NSLockæ­»é”
               recursiveLock.lock()
               if n <= 0 {
                   print(n)
               }
               else {
                   print(n)
                   printPattern(n: n - 5)
                   print(n)
               }
//               nsLock.unlock()
               recursiveLock.unlock()
           }
```



### æ‚²è§‚é”å’Œä¹è§‚é”

æ€»æ˜¯å‡è®¾æœ€åçš„æƒ…å†µï¼Œæ¯æ¬¡å»æ‹¿æ•°æ®çš„æ—¶å€™éƒ½è®¤ä¸ºåˆ«äººä¼šä¿®æ”¹ï¼Œæ‰€ä»¥æ¯æ¬¡åœ¨æ‹¿æ•°æ®çš„æ—¶å€™éƒ½ä¼šä¸Šé”ï¼Œè¿™æ ·åˆ«äººæƒ³æ‹¿è¿™ä¸ªæ•°æ®å°±ä¼šé˜»å¡ç›´åˆ°å®ƒæ‹¿åˆ°é”ï¼ˆ**å…±äº«èµ„æºæ¯æ¬¡åªç»™ä¸€ä¸ªçº¿ç¨‹ä½¿ç”¨ï¼Œå…¶å®ƒçº¿ç¨‹é˜»å¡ï¼Œç”¨å®Œåå†æŠŠèµ„æºè½¬è®©ç»™å…¶å®ƒçº¿ç¨‹**ï¼‰ã€‚ä¼ ç»Ÿçš„å…³ç³»å‹æ•°æ®åº“é‡Œè¾¹å°±ç”¨åˆ°äº†å¾ˆå¤šè¿™ç§é”æœºåˆ¶ï¼Œæ¯”å¦‚è¡Œé”ï¼Œè¡¨é”ç­‰ï¼Œè¯»é”ï¼Œå†™é”ç­‰ï¼Œéƒ½æ˜¯åœ¨åšæ“ä½œä¹‹å‰å…ˆä¸Šé”ã€‚Javaä¸­`synchronized`å’Œ`ReentrantLock`ç­‰ç‹¬å é”å°±æ˜¯æ‚²è§‚é”æ€æƒ³çš„å®ç°ã€‚

æ€»æ˜¯å‡è®¾æœ€å¥½çš„æƒ…å†µï¼Œæ¯æ¬¡å»æ‹¿æ•°æ®çš„æ—¶å€™éƒ½è®¤ä¸ºåˆ«äººä¸ä¼šä¿®æ”¹ï¼Œæ‰€ä»¥ä¸ä¼šä¸Šé”ï¼Œä½†æ˜¯åœ¨æ›´æ–°çš„æ—¶å€™ä¼šåˆ¤æ–­ä¸€ä¸‹åœ¨æ­¤æœŸé—´åˆ«äººæœ‰æ²¡æœ‰å»æ›´æ–°è¿™ä¸ªæ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨ç‰ˆæœ¬å·æœºåˆ¶å’ŒCASç®—æ³•å®ç°ã€‚**ä¹è§‚é”é€‚ç”¨äºå¤šè¯»çš„åº”ç”¨ç±»å‹ï¼Œè¿™æ ·å¯ä»¥æé«˜ååé‡**ï¼Œåƒæ•°æ®åº“æä¾›çš„ç±»ä¼¼äº**write_conditionæœºåˆ¶**ï¼Œå…¶å®éƒ½æ˜¯æä¾›çš„ä¹è§‚é”ã€‚åœ¨Javaä¸­`java.util.concurrent.atomic`åŒ…ä¸‹é¢çš„åŸå­å˜é‡ç±»å°±æ˜¯ä½¿ç”¨äº†ä¹è§‚é”çš„ä¸€ç§å®ç°æ–¹å¼**CAS**å®ç°çš„ã€‚




https://blog.csdn.net/tennysonsky/article/details/46494077

https://segmentfault.com/a/1190000016611415

https://juejin.im/post/5d554410f265da03b21532cd#heading-12

https://www.cnblogs.com/linux-37ge/p/10208369.html

